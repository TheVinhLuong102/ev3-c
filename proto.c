
/*  proto.c was generated by yup.py (yupp) 0.7b5
    out of proto.yu-c at 2014-09-17 18:53
 *//**
 *  \file  proto.c (proto.yu-c)
 *  \brief  ev3-c prototype.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#include <stdbool.h>
#include <stdio.h>

#include "lego.h"
#include "ev3_wlan.h"
#include "ev3_link.h"
#include "ev3_misc.h"

#define OUT_A    0x01
#define OUT_B    0x02
#define OUT_C    0x04
#define OUT_D    0x08
#define OUT_ALL  0x0F

#define IN_1  0
#define IN_2  1
#define IN_3  2
#define IN_4  3

bool tacho_start( uint8_t port, uint8_t val )
{

	uint8_t lmc[] = { opOUTPUT_POWER, LC0( 0 ), LC0( port ), LC0( val ), opOUTPUT_START, LC0( 0 ), LC0( port ) };
	int n = ev3_tcp_direct( 0, 0, lmc, sizeof( lmc ), DIRECT_COMMAND_NO_REPLY );
	if ( n == EOF ) return ( false );

	return ( false );
}

bool tacho_stop( uint8_t port )
{

	uint8_t lmc[] = { opOUTPUT_STOP, LC0( 0 ), LC0( port ),LC0( 0 ) };
	int n = ev3_tcp_direct( 0, 0, lmc, sizeof( lmc ), DIRECT_COMMAND_NO_REPLY );
	if ( n == EOF ) return ( false );

	return ( false );
}

bool sensor_name( uint8_t port, void *buf )
{
	size_t globals = 16;
	uint8_t lmc[] = { opINPUT_DEVICE, LC0( GET_NAME ), LC0( 0 ), LC0( port ), LC0( globals ), GV0( 0 ) };
	int n = ev3_tcp_direct( 16, 0, lmc, sizeof( lmc ), DIRECT_COMMAND_REPLY );
	if ( n == EOF ) return ( false );

	sleep_msec( 100 );
	return ( ev3_tcp_direct_reply( n, buf, &globals ) == DIRECT_REPLY );
}

bool sensor_value( uint8_t port, void *buf )
{
	size_t globals = 1;
	uint8_t lmc[] = { opINPUT_READ, LC0( 0 ), LC0( port ), LC0( 0 ), LC0( 0 ), GV0( 0 ) };
	int n = ev3_tcp_direct( 1, 0, lmc, sizeof( lmc ), DIRECT_COMMAND_REPLY );
	if ( n == EOF ) return ( false );

	sleep_msec( 100 );
	return ( ev3_tcp_direct_reply( n, buf, &globals ) == DIRECT_REPLY );
}

bool ev3_connect( void )
{
	if ( ev3_udp_connect() != EOF ) {
		int i;

		for ( i = 0; i < 10; i++ ) {
			sleep_msec( 1000 );
			if ( ev3_udp_catch_address() > 0 ) break;
		}
		ev3_udp_disconnect();
	}
	if ( ev3_tcp_connect() == EOF ) return ( false );
	if ( ev3_tcp_unlock_request() == EOF ) return ( false );

	sleep_msec( 100 );
	ev3_tcp_unlock_reply();

	return ( true );
}

int main( int argc, char **argv )
{
	char buf[ 256 ];
	uint8_t val;

	if ( !ev3_connect()) return ( 1 );

	tacho_start( OUT_ALL, 20 );
	sleep_msec( 2000 );
	tacho_stop( OUT_ALL );

	sleep_msec( 100 );
	if ( sensor_name( IN_1, buf )) printf( "IN_1 '%s'\n", buf );

	sleep_msec( 100 );
	if ( sensor_value( IN_1, &val )) printf( "IN_1 value = %d\n", val );

	ev3_tcp_disconnect();

	return ( 0 );
}
